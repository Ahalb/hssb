(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0c910f"],{"580f":function(e,n,t){"use strict";t.r(n);var s=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},o=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("ol",{staticClass:"list-group"},[t("li",[e._v(" You connect to the server. You tell it your name and it tells you and others information about the connection. "),t("details",[t("summary",[e._v("Details")]),e._v(" When you connect, the server asks for you name by sending "),t("code",[e._v("NAME")]),e._v(". You respond by sending "),t("code",[e._v("NAME <your_name>")]),e._v(" (if you're the host, it looks like "),t("code",[e._v("NAME <your_name> HOST")]),e._v("). If someone else is using that name, the server sends "),t("code",[e._v("NAME_IN_USE")]),e._v(" and closes the connection. If the name is valid, the server send "),t("code",[e._v("SUCCESS")]),e._v(". It immediately sends a "),t("code",[e._v("HOST <name_of_host>")]),e._v(" message to tell you who the host is. It also updates the online list and sends an "),t("code",[e._v("ONLINE <name_one>,<name_two>...")]),e._v(" message to everyone to let them know the user list has updated."),t("br"),e._v(" Code: "),t("pre",[t("code",[e._v("case 'NAME': // Client registration response\n  // If any client has that name, send an error and close\n  if (this.clients.some(e => e.name === params.replace(/ HOST$/, ''))) {\n    client.sendMessage('NAME_IN_USE');\n    client.connnection.close();\n    break;\n  }\n  // Set their name as the name they gave\n  client.name = params;\n  // If the client name ends with HOST, make them a host and remove that from their name\n  if (params.match(/ HOST$/)) { // If the client is joining as a host, they will send HOST at the end of their message\n    this.clients.forEach(client => {\n      // Set every client as not the host\n      client.isHost = false\n    });\n    // Set the client that sent the message as the host\n    client.isHost = true;\n    // Make sure their name doesn't end with HOST\n    client.name = params.replace(/ HOST$/, '');\n  }\n  // Inform the client it wored\n  client.sendMessage('SUCCESS');\n  // Tell them who the host is and update the online list\n  client.sendMessage(`HOST ${this.getHost()?.name || ''}`);\n  this.updateOnline();\n  break;\n")])])])]),t("li",[e._v(" When you buzz or clear, the server receives the message and echoes it to everyone else "),t("details",[t("summary",[e._v("Details")]),e._v(" Buzz messages are sent as "),t("code",[e._v("BUZZ <name_of_buzzer>")]),t("br"),e._v(" Clear messages are sent as "),t("code",[e._v("CLEAR")]),t("br"),e._v(" The server relays these messages to everyone connected except you, to avoid infinite loops (those are never fun) "),t("pre",[t("code",[e._v("// Echo buzz/clear messages\n// this.broadcast sends the message to everyone except the sender\ncase 'BUZZ': this.broadcast(`BUZZ ${client.name}`, senderConnection); break;\ncase 'CLEAR': this.broadcast(`CLEAR`, senderConnection); break;")])])])]),t("li",[e._v(" There are two ways users can be made host - either when they connect or when a host makes them the host "),t("details",[t("summary",[e._v("Details")]),e._v(" During connection, users can connect as a host by adding the "),t("code",[e._v("HOST")]),e._v(" option the the "),t("code",[e._v("NAME")]),e._v(" command Host messages are sent as "),t("code",[e._v("HOST <new_host>")]),t("br"),e._v(" The server sends this to everyone except you. "),t("pre",[t("code",[e._v("case 'HOST':\n  this.clients.forEach(client => client.isHost = false)\n  // Makes sure everyone except the new host isn't a host\n  this.clients.find(client => e.name === params).isHost = true;\n  // Let everyone know\n  this.broadcast(`HOST ${params}`, senderConnection);\n  break;")])])])]),t("li",[e._v(" When you disconnect, the server updates the online list "),t("details",[t("summary",[e._v("Details")]),e._v(" That's all there is - here's the code "),t("pre",[t("code",[e._v("connection.on('close', (code, desc) => {\n  // On close, update online list\n  this.log('CLOSE', code, desc);\n  // Remove clients that are disconnected from the list\n  this.clients = this.clients.filter(client => client.connection.connected);\n  // Send the updated list to everyone\n  this.updateOnline();\n});\n          ")])])])])]),t("br"),t("h4",[e._v("See the full code")]),t("details",[t("summary",[e._v("Server")]),t("pre",[t("code",[e._v("import { server as WebSocketServer, connection, request, IMessage } from 'websocket';\nimport { createServer, Server } from 'http';\nimport Client from './client';\n\nexport default class WSServer {\n  server: Server;\n\n  wsServer: WebSocketServer;\n\n  clients: Client[];\n\n  constructor() {\n    this.server = createServer((request, response) => {\n      this.log('RECEIVED REQUEST', 'FOR', request.url)\n      // This isn't a web server - give a 404 if someone accesses it through the browser\n      response.writeHead(404);\n      response.end();\n    });\n    this.server.listen(process.env.PORT || 8080, () =>  this.log('LISTEN', `on port ${process.env.PORT || 8080}`));\n    this.wsServer = new WebSocketServer({\n      httpServer: this.server,\n      autoAcceptConnections: false,\n    })\n    this.wsServer.on('request', (request) => this.onRequest(request))\n    this.clients = [];\n  }\n\n async onRequest(request: request) {\n    if (this.originAllowed(request.origin)) {\n      // request.reject();\n      this.log('REJECT ORIGIN', request.origin);\n      // return;\n    }\n    let connection = request.accept('echo-protocol', request.origin);\n    this.log('ACCEPT CONNECTION');\n    connection.on(\"message\", (data: IMessage) => this.onMessage(data, connection));\n    connection.on('close', (code, desc) => {\n      // On close, update online list\n      this.log('CLOSE', code, desc);\n      this.clients = this.clients.filter(e => e.conn.connected);\n      this.updateOnline();\n    });\n    let client = new Client();\n    client.conn = connection;\n    this.clients.push(client);\n    // Initiate client registration\n    client.sendMessage('NAME');\n  }\n\n  getClientWithConnection(connection: connection) {\n    return this.clients.find(client => client.connection === connection);\n  }\n\n  getHost() {\n    return this.clients.find(client => client.isHost);\n  }\n\n  async onMessage(message: IMessage, senderConnnection: connection) {\n    this.log('RECEIVE', message.utf8Data)\n    const msg = message.utf8Data;\n    let client = this.getClientWithConnection(senderConnection);\n    let command = msg.match(/^\\S+/) ? msg.match(/^\\S+/)![0] : null;\n    let params = msg.match(/ (\\S+\\s)*(\\S+)$/) ? msg.match(/ (\\S+\\s)*(\\S+)$/)![0].slice(1) : '';\n    switch (command) {\n      case 'NAME': // Client registration response\n        // If name in use, send an error and close\n        if (this.clients.some(client => client.name === params.replace(/ HOST$/, ''))) {\n          client.sendMessage('NAME_IN_USE');\n          client.connection.close();\n          break;\n        }\n        client.name = params;\n        if (params.match(/ HOST$/)) { // If the client is joining as a host, they will send HOST at the end of their message\n          this.clients.forEach(client => client.isHost = false)\n          client.isHost = true;\n          client.name = params.replace(/ HOST$/, '');\n        }\n        client.sendMessage('SUCCESS');\n        // Tell them who the host is and update the online list\n        client.sendMessage(`HOST ${this.getHost()?.name || ''}`);\n        this.updateOnline();\n        break;\n      case 'HOST':\n        this.clients.forEach(client => client.isHost = false)\n        this.clients.find(client => client.name === params).isHost = true;\n        this.broadcast(`HOST ${params}`, senderConnection);\n        break;\n      // Echo buzz/clear messages\n      case 'BUZZ': this.broadcast(`BUZZ ${client.name}`, senderConnection); break;\n      case 'CLEAR': this.broadcast(`CLEAR`, senderConnection); break;\n      default: this.error(new Error(`UNKNOWN MESSAGE TYPE: ${msg}`)); break;\n    }\n  }\n\n  async updateOnline() {\n    let names = this.clients.map(client => client.name);\n    this.broadcast(`ONLINE ${names.join(',')}`)\n  }\n\n  async broadcast(message: string, excluding: connection = null) {\n    this.wsServer.connections.filter(connecttion => excluding === null || connection !== excluding).forEach(connection => {\n      this.sendMessage(message, connection)\n    })\n  }\n\n  async sendMessage(message: string, to: connection) {\n    this.log('SEND', message);\n    to.send(message);\n  }\n\n  async originAllowed(origin: string) {\n    return true;\n  }\n\n  async error(err: Error) {\n    console.error('[SERVER]', err);\n  }\n\n  async log(type: string, ...messages: string[] | any[]) {\n    console.log('[SERVER]', type, ...messages);\n  }\n}\n\nlet s = new WSServer();")])])]),t("details",[t("summary",[e._v("Client logic")]),e._v(" Note that this is not the full code, just the part that communicates with the server "),t("pre",[t("code",[e._v("import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  state: {\n    name: '',\n    alerts: [] as string[],\n    connectionState: 'Disconnected',\n    connection: new WebSocket('wss://scholar-bowl-server.herokuapp.com', 'echo-protocol'),\n    activeBuzzer: null as string | null,\n    onlineList: [] as string[],\n    host: '',\n  },\n  mutations: {\n    setName(state, name: string) {\n      state.name = name;\n      localStorage.hasName = JSON.stringify(name);\n    },\n    addAlert(state, name: string) {\n      state.alerts.push(name);\n    },\n    removeAlert(state, name: string) {\n      state.alerts = state.alerts.filter(e => e !== name);\n    },\n    changeConnectionState(state, to: string) {\n      state.connectionState = to;\n    },\n    setConnection(state, connection) {\n      state.connection = connection;\n    },\n    setBuzzer(state, to: string) {\n      state.activeBuzzer = (to === 'null' ? null : to);\n    },\n    setOnline(state, to: string[]) {\n      state.onlineList = to;\n    },\n    setHost(state, user) {\n      state.host = user;\n    },\n  },\n  actions: {\n    start({ commit }) {\n      if (!localStorage) {\n        alert(\"Your browser doesn't support local storage - that's an issue. Please use a modern browser that does\");\n        return;\n      }\n      let name = '';\n      if (localStorage.hasName) {\n        name = JSON.parse(localStorage.hasName);\n      } else {\n        commit('addAlert', \"I don't know who you are! Tell me in the upper left\");\n        commit('addAlert', \"New here? Try adding me to the home screen or installing me as an app!\");\n      }\n      commit('setName', name?.length ? name : 'Anonymous');\n    },\n    async connect({ commit, dispatch }, host = false) {\n      commit('changeConnectionState', 'Connecting...')\n      dispatch('join', host)\n    },\n    async disconnect({ commit, state }) {\n      state.connection.close();\n      commit('changeConnectionState', 'Disconnected')\n    },\n    buzz({ state, commit }) {\n      if (state.activeBuzzer === null) {\n        state.connection.send(`BUZZ ${state.name}`)\n        commit('setBuzzer', state.name);\n        commit('addAlert', 'You buzzed');\n      } else commit('addAlert', `${state.activeBuzzer === state.name ? 'You have' : `${state.activeBuzzer} has`} already buzzed`);\n    },\n    clear({ state, commit }) {\n      state.connection.send('CLEAR')\n      commit('setBuzzer', 'null');\n      commit('addAlert', 'You cleared');\n    },\n    async join({ commit, dispatch, state }, host = false) {\n      let connection = new WebSocket('wss://scholar-bowl-server.herokuapp.com', 'echo-protocol');\n      // let connection = new WebSocket('ws://localhost:8080', 'echo-protocol')\n      connection.onopen = (e) => {\n        commit('changeConnectionState', 'Connected')\n      }\n      connection.onclose = (e) => {\n        commit('addAlert', `Connection ${e.wasClean ? '' : '(not cleanly) '}closed${e.reason.length ? `: ${e.reason}` : ''}`)\n      };\n      connection.onmessage = (e) => {\n        let msg = e.data as string;\n        let command = msg.match(/^\\S+/) ? msg.match(/^\\S+/)![0] : null;\n        let params = msg.match(/ (\\S+\\s)*(\\S+)$/) ? msg.match(/ (\\S+\\s)*(\\S+)$/)![0].slice(1) : '';\n        if (command === null) return;\n        switch(command) {\n          case 'BUZZ':\n            dispatch('onBuzz', params);\n            break;\n          case 'CLEAR':\n            dispatch('onClear');\n            break;\n          case 'NAME':\n            if (host) {\n              commit('setHost', state.name);\n            }\n            connection.send(`NAME ${state.name}${host ? ' HOST' : ''}`);\n            break;\n          case 'NAME_IN_USE':\n            if (state.name.startsWith('Anonymous')) {\n              let match = state.name.match(/\\d+$/);\n              let num = parseInt(match ? match[0] : '0', 10);\n              commit('setName', `Anonymous${num + 1}`)\n              this.dispatch('join', host)\n            } else {\n              commit('addAlert', 'Someone else is using that name. Please try a different one and reconnect');\n              this.dispatch('disconnect')\n            }\n            break;\n          case 'SUCCESS':\n            commit('addAlert', 'Successfully connected');\n            break;\n          case 'HOST':\n            if (params === state.name) {\n              commit('addAlert', 'You are now the host')\n            }\n            commit('setHost', params);\n            break;\n          case 'ONLINE':\n            commit('setOnline', params.trim().split(','));\n            break;\n          default:\n            commit('addAlert', `Unknown message type: ${msg}`);\n            break;\n        }\n      }\n      connection.onerror = (e) => {\n        commit('addAlert', `ERROR: ${e}`)\n        console.error('error', e);\n      }\n      commit('setConnection', connection);\n    },\n    onBuzz({ commit }, from: string) {\n      commit('addAlert', `${from} buzzed`)\n      commit('setBuzzer', from);\n    },\n    onClear({ commit, state }) {\n      commit('addAlert', `${state.host} cleared`)\n      commit('setBuzzer', 'null');\n    },\n    host({ state, commit }, user: string) {\n      state.connection.send(`HOST ${user}`);\n      commit('setHost', user)\n    },\n  },\n  modules: {\n  },\n})")])])]),t("details",[t("summary",[e._v("App code")]),e._v(" This is the code that controls what you see. "),t("pre",[t("code",[e._v('<template>\n  <div id="app" class="h-100">\n    <router-link to="#main" class="skiplink" @click.native="scrollFix(\'#main\')">Skip to content</router-link>\n    <Navbar />\n    <div class="container pt-3">\n      <h2 v-if="showName">{'),e._v("{ location }}</h2>\n      <router-view  class=\"mb-5 pb-5\"/>\n      <br class=\"d-block d-md-none\">\n      <br class=\"d-block d-sm-none\">\n      <br class=\"d-block d-sm-none\">\n      <Footer />\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue } from 'vue-property-decorator';\nimport store from '@/store';\nimport BootstrapVue from 'bootstrap-vue';\nimport Navbar from '@/components/Navbar.vue';\nimport Footer from '@/components/Footer.vue';\nimport 'nprogress/nprogress.css'\n\nVue.use(BootstrapVue);\n\n@Component({\n  components: {\n    Navbar,\n    Footer,\n  }\n})\nexport default class App extends Vue {\n  mounted() {\n    document.title = 'HS Scholar Bowl'\n    store.dispatch('start')\n  }\n\n  scrollFix(hashbang: string) {\n      window.location.hash = hashbang;\n  }\n\n  get showName() {\n    return !(['Main'].includes(this.location));\n  }\n\n  get location() {\n    let { name } = this.$route;\n    return name || '';\n  }\n}\n<\/script>\n<style lang=\"scss\">\n@import '@/styles/global.scss';\n</style>\n<style scoped lang=\"scss\">\n@import '@/styles/global.scss';\n.skiplink {\n  background-color: $primary;\n  padding: 3px 6px;\n  position: absolute;\n  top: 5px;\n  left: 50%;\n  transform: translateX(-50%);\n  border: 0 none;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  white-space: nowrap;\n  width: 1px;\n  color: $secondary;\n  box-shadow: 2px 2px 8px 0 rgba(0, 0, 0, 0.75);\n  z-index: 2;\n}\n.skiplink:focus {\n  clip: auto;\n  height: auto;\n  position: fixed;\n  width: auto;\n}\n.skiplink:focus:hover {\n  color: $dark;\n}\n</style>")])])]),t("details",[t("summary",[e._v("Routing")]),e._v(" This controls what you see. It allows you to navigate pages without reloading "),t("pre",[t("code",[e._v("import Vue from 'vue'\nimport VueRouter, { RouteConfig } from 'vue-router'\nimport NProgress from 'nprogress';\n\nVue.use(VueRouter)\n\n  const routes: Array<RouteConfig> = [\n  {\n    path: '/',\n    name: 'Main',\n    component: () => import('@/views/Main.vue'),\n  },\n  {\n    path: '/about',\n    name: 'How it Works',\n    component: () => import('@/views/HowItWorks.vue'),\n  }\n]\n\nconst router = new VueRouter({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes\n})\n\nrouter.beforeResolve((to, from, next) => {\n  // If this isn't an initial page load.\n  if (to.name) {\n      // Start the route progress bar.\n      NProgress.start()\n  }\n  next()\n})\n\nrouter.afterEach((to, from) => {\n  // Complete the animation of the route progress bar.\n  NProgress.done()\n})\n\nexport default router\n")])])]),t("details",[t("summary",[e._v("Main view")]),e._v(" This is the primary interface "),t("pre",[t("code",[e._v('<template>\n  <main id="main">\n      <button\n        class="btn btn-primary d-inline btn-sm align-baseline mt-3 mt-sm-0 col-md"\n        v-if="store.state.connectionState !== \'Connected\'"\n        @click="connect(false)"\n      >Connect</button>\n      <button\n        class="btn btn-primary d-inline btn-sm align-baseline col-md"\n        v-else\n        @click="store.dispatch(\'disconnect\')"\n      >Disconnect</button>\n      <button\n        class="btn btn-primary d-inline btn-sm align-baseline mt-2 col-md"\n        v-if="store.state.connectionState !== \'Connected\'"\n        @click="connect(true)"\n        v-b-tooltip.hover\n        title="Connect as a host; the host can clear buzzes"\n      >Connect as host</button>\n      <button\n        class="btn btn-primary d-inline btn-sm align-baseline col-md mt-2"\n        v-else\n        @click="reconnect"\n      >Reconnect</button>\n    <button @click="buzz" class="btn btn-secondary btn-lg w-100 mb-3 mt-3">Buzz</button>\n    <button @click="clear" class="btn btn-secondary btn-lg w-100 mb-3" v-if="isHost">Clear</button>\n    <div v-if="onlineList.length" class="mb-3">\n      <h4>Online</h4>\n      <b-list-group>\n        <b-list-group-item\n          v-for="user in onlineList"\n          :key="user"\n          :active="activeBuzzer === user"\n        >\n          <span class="align-middle">\n            <span v-b-tooltip.hover :title="`${user} is the host`">{'),e._v("{ host === user ? '◆' : ''}}</span>\n            {"),e._v("{ user }}\n          </span>\n          <b-button class=\"btn-sm float-right make-host\" v-if=\"host !== user && isHost\" @click=\"makeHost(user)\">Make Host</b-button>\n        </b-list-group-item>\n      </b-list-group>\n    </div>\n    <a class=\"sr-only\" href=\"#footer\">Skip alerts</a>\n    <Alerts class=\"sticky-bottom mb-5 pb-5\"/>\n  </main>\n</template>\n<script lang=\"ts\">\nimport { Vue, Component } from 'vue-property-decorator';\nimport store from '@/store';\nimport Alerts from '@/views/Alerts.vue';\nimport debounce from 'lodash.debounce'\n@Component({\n  components: {\n    Alerts,\n  }\n})\nexport default class Main extends Vue {\n  get name() {\n    return store.state.name;\n  }\n\n  get isHost() {\n    return this.host === this.name;\n  }\n\n  get onlineList() {\n    return store.state.onlineList;\n  }\n\n  get host() {\n    return store.state.host;\n  }\n\n  get activeBuzzer() {\n    return store.state.activeBuzzer;\n  }\n\n  makeHost(user: string) {\n    store.dispatch('host', user);\n    store.commit('addAlert', 'You are no longer the host')\n  }\n\n  buzz() {\n    store.dispatch('buzz')\n  }\n\n  clear() {\n    store.dispatch('clear')\n  }\n\n  get store() {\n    return store;\n  }\n\n  updateName(event: string) {\n    store.commit('setName', event);\n    if (!event.includes(',') && event.trim().length) this.debounceReconnect();\n  }\n\n  debounceReconnect = debounce(this.reconnect, 500);\n\n  connect(host = false) {\n    store.dispatch('connect', host);\n  }\n\n  async reconnect() {\n    let currentlyIsHost = store.state.name === store.state.host;\n    await store.dispatch('disconnect');\n    await store.dispatch('connect', currentlyIsHost);\n  }\n}\n<\/script>")])])]),t("details",[t("summary",[e._v("Alerts")]),t("pre",[t("code",[e._v('<template>\n  <div>\n    <b-alert\n      v-for="(alert, index) in alerts"\n      :key="`${alert}${index}`"\n      show=5\n      fade\n      dismissible\n    >\n    {'),e._v("{ alert }}\n    </b-alert>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue } from 'vue-property-decorator';\nimport store from '@/store';\n\n@Component\nexport default class Alerts extends Vue {\n  get alerts() {\n    return store.state.alerts;\n  }\n}\n<\/script>")])])]),t("details",[t("summary",[e._v("Footer")]),t("pre",[t("code",[e._v('<template functional>\n  <footer class="w-100 bg-secondary text-white p-2 fixed-bottom mt-3 row ml-0" id="footer">\n    <span class="col-md-9 col-12">\n      Built with Vue.js and TypeScript, styled with Bootstrap Vue, made in VSCode, and deployed on GitHub Pages. Uses a websocket server deployed on Heroku for peer-to-peer communication.\n    </span>\n    <div class="col-12 col-md-3">\n      <a href="https://hsscholarbowl.github.com/hssb" class="col">Code</a>\n      <a href="https://hsscholarbowl.github.com/server" class="ml-2 col clearfix" style="position: relative; right: 0px">Server</a>\n    </div>\n  </footer>\n</template>')])])]),t("details",[t("summary",[e._v("Navbar")]),t("pre",[t("code",[e._v('<template>\n  <div>\n    <b-navbar toggleable="lg" variant="secondary" class="text-white">\n      <b-navbar-brand><router-link to="/">Home</router-link></b-navbar-brand>\n      <b-navbar-toggle class="bg-primary" target="nav-collapse"></b-navbar-toggle>\n      <b-collapse id="nav-collapse" is-nav>\n        <b-navbar-nav>\n          <b-nav-item><router-link to="/about">How it works</router-link></b-nav-item>\n        </b-navbar-nav>\n        <b-navbar-nav class="ml-auto">\n          <b-nav-form>\n            Welcome,<pre> </pre><b-form-input size="sm" class="mr-sm-2" :value="name" @input="updateName" placeholder="wait a minute...who are you?"></b-form-input>\n          </b-nav-form>\n        </b-navbar-nav>\n      </b-collapse>\n    </b-navbar>\n  </div>\n</template>\n<script lang="ts">\nimport { Component, Vue } from \'vue-property-decorator\';\nimport store from \'@/store\';\nimport debounce from \'lodash.debounce\'\n\n@Component\nexport default class Navbar extends Vue {\n  get name() {\n    return store.state.name\n  }\n\n  get store() {\n    return store;\n  }\n\n  updateName(event: string) {\n    store.commit(\'setName\', event);\n    if (!event.includes(\',\') && event.trim().length) this.debounceReconnect();\n  }\n\n  debounceReconnect = debounce(this.reconnect, 500);\n\n  async reconnect() {\n    let currentlyIsHost = store.state.name === store.state.host;\n    await store.dispatch(\'disconnect\');\n    await store.dispatch(\'connect\', currentlyIsHost);\n  }\n\n}\n<\/script>')])])]),t("details",[t("summary",[e._v("Stylesheet")]),t("pre",[t("code",[e._v("html, body {\n  height: 100%;\n}\n\n$primary: rgb(175, 175, 175);\n$secondary: darkred;\n\n.list-group-item.active {\n  background-color: $secondary !important;\n}\n\n.list-group-item.active > .make-host {\n  background-color: $primary !important;\n  color: $secondary !important;\n}\n\npre code {\n  color: #e83e8c !important\n}")])])]),t("details",[t("summary",[e._v("Deploy script")]),t("pre",[t("code",[e._v('/* eslint-disable @typescript-eslint/no-var-requires */\n// @ts-nocheck\nconst execa = require("execa");\nconst fs = require("fs");\n\n(async () => {\n  try {\n    console.log(\'Creating branch...\');\n    await execa("git", ["checkout", "--orphan", "gh-pages"]);\n    console.log("Building...");\n    await execa("npm", ["run", "build"]);\n    // Understand if it\'s dist or build folder\n    console.log(\'Getting folder...\');\n    const folderName = fs.existsSync("dist") ? "dist" : "build";\n    console.log(\'Adding changes...\');\n    await execa("git", ["--work-tree", folderName, "add", "--all"]);\n    console.log(\'Committing changes...\');\n    await execa("git", ["--work-tree", folderName, "commit", "-m", "gh-pages"]);\n    console.log("Pushing to gh-pages...");\n    await execa("git", ["push", "origin", "HEAD:gh-pages", "--force"]);\n    console.log(\'Deleting branch files...\');\n    await execa("rm", ["-r", folderName]);\n    console.log(\'Checking out master...\');\n    await execa("git", ["checkout", "-f", "master"]);\n    console.log(\'Removing branch..\');\n    await execa("git", ["branch", "-D", "gh-pages"]);\n    console.log("Successfully deployed");\n  } catch (e) {\n    console.log(e.message);\n    process.exit(1);\n  }\n})();\n')])])]),e._v(" Still not enough code? See the full source for the website and server on "),t("a",{staticClass:"text-secondary",attrs:{href:"https://github.com/hsscholarbowl"}},[e._v("GitHub")])])}],a=t("2877"),r={},i=Object(a["a"])(r,s,o,!1,null,null,null);n["default"]=i.exports}}]);
//# sourceMappingURL=chunk-2d0c910f.3bb1223e.js.map